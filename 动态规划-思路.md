## 动态规划	

- 一般是求**最值**问题，如**最长**递增子序列，**最小**编辑距离
- 求动态规划的最值，核心问题是**穷举**
- DP的穷举中存在很多**重复子问题** ， 效率低下， 可以使用**备忘录**（自顶向下）或者**DP-Table**（自底向上）来解决
- DP一定会有 【**最优子结构**】，通过子问题的最值得到原问题的最值
- 要符合「最优子结构」，子问题间必须**互相独立**， 
- 在**重复子问题**和**最优子结构**的基础上，通过**状态转移方程**来正确的穷举，即**DP3要素**
- 同时还有**自底向上**



### 状态转移方程-思路

> **明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。
>
> 「状态」，也就是原问题和子问题中会变化的变量
>
> 「选择」，也就是导致「状态」产生变化的行为

大致框架：

```
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```



### DP

**DP思路： 利用原问题与子问题的关系，将其变成 大问题的解 = 小问题的解的函数， 从而将问题变成size的扩展即可，当size到达最大后，原问题解决了**

DP的keypoint

1. 转移方程（**即大问题和小问题之间的关系**）

   > ```
   >  1）定义状态：定义一个状态，例如f(i) = 到a[i]为止到最小值
   >  2）设计转移方程：根据如上状态方程定义，则有 f(i+1) = min(f(i), a[i+1])
   >  
   >  tip:
   >  转移方程的设计完全依赖于状态的定义，并不是什么样的状态定义，都能有状态转移方程，因此，状态定义决定了该DP方法能否实现
   > ```

   其中定义状态比较常见的几种方式可以总结汇总一下 

2. 初始条件的设置： Dp本质还是迭代，总要有一个迭代的初值。

3. 特殊处理小size的问题：有些情况，由于size太小，没法带入转移方程中。





参见72.编辑距离问题 十分重要